ECE13 Lab05: Reverse Polish Notation  
Date: April 29, 2025

“Author: Akshera Paladhi (apaladhi@ucsc.edu)”  
“Collaborators: Prithika Thanigaivelan (pthaniga@ucsc.edu) Arthon Greenspan (agreensp@ucsc.edu)”

My collaborators and I discussed the errors specifically for too many items and too few items and we also discussed how to change the code so that way the same results on the terminal would also show up on the nucleo output as well. 

▪ In the next section you should provide a summary of the lab in your own words. Highlight what you thought were the important aspects of the lab. If these differ from how the lab manual presents things, make a note of that. 

This lab focuses on implementing the RPN or Reverse Polish Notation in the C, which performs basic operations like addition, subtraction, multiplication, and division. The main target of this was to parse a string containing an RPN expression and evaluate the result using the stack functions. I also felt like handling errors was an important aspect of this lab because this made sure that only if the user inputted valid tokens such numerical values or supported operators, the input would  be processed and if not the appropriate error messages were returned. Another aspect of this lab that was crucial is the order of the operators and operand matters as this impacts the RPN calculation. The lab manual also emphasized on debugging error conditions so that was another important aspect of this lab because there could have been so many errors if I have not used the test cases and the Nucleo. There was important aspect though that I felt differed from how the lab manual presented itself like the specific error of stack underflow and the error which stated that too few items remained because I felt as though that both of these terms are very easy to get confused with since they seemed similar and I feel like the lab manual could have discussed more about each of these errors more clearly. Overall, I felt that this lab was a great learning experience to understand how RPN calculators worked and how I could implement it in C. 

▪ The following section should describe your approach to the lab. What was your general approach to the lab? Did you read the manual first or what were your first steps? What went wrong as you worked through it? What worked well? How would you approach this lab differently if you were to do it again? How did you work with other students in the class and what did you find helpful/unhelpful? 

My general approach to the lab was to read the entire manual first and then after understanding the main idea of it, I would go back and add or make the necessary files for this lab. After this I would break it down by reading and understanding what I need to implement for each file. I would start off with the file that I felt was the easiest to do so that way I could slowly work my way up and the lab manual also made that easy for me because I noticed that they gave instructions so that the student would work with the files in that specific order. For example, the lab manual listed stack.c file so I started off with that file and then went on from that. This really helped me understand very clearly what exactly I had to do. I felt that the stack.c and stack_test.c files worked really well and were easy. Most of rpn.c did work out fine but I did run into some issues where learning to make sure the token was valid or not was difficult for me. Also, when I almost finished my lab I realized that I could not use magic numbers so I had to go back to all my files to check and see if I had those. This is when I realized that I had a tough time defining TRUE and FALSE since they are booleans so I learned that I could use type cast (int8_t) so that way there would be no errors. However, I was confused if I could use TRUE or FALSE or change it because it was mentioned that even booleans were magic numbers. I got confused and changed it. I also realized that I should use all the stack functions because before I did it differently where I found my errors just stack push or stackpop but then I realized I could use stack size and stack full to get my errors and that made my code more easier. If I were to do this lab again I would write a pseudocode first and then start writing my code because most of the time I just went for it and I found that later on I had such issues because I was missing important pieces of the information. I worked with other students by asking questions on how they approached the issue that I was facing and this helped me get a better understanding of what went wrong and then I would go back to my code and fix it. I found the reading very helpful because it taught me how to use certain functions, allowing me to quickly find the most efficient way to implement something instead of spending hours searching for how it works. Overall, the lab was more difficult than the other labs and extremely time consuming but I learned many things through the process.  

▪ The final section should describe the results of you implementing the lab. How did it end up finally? How many hours did you end up spending on it? What did you like about it? What did you dislike? Was this a worthwhile lab? Do you have any suggestions for altering it to make it better? What were the hardest parts of it? Did the points distribution for the grading seem appropriate? Did the lab manual cover the material in enough detail to start you off? Did examples or discussions during class help you understand this lab or would more teaching on the concepts in this lab help? 

I spent almost over 20 hours on this lab and I felt like the majority of the time it was spending hours on one error or debugging issue. I liked how this lab taught me so many more things about the C programming language like magic numbers, string manipulation, make files, and the logic behind RPN. I also felt like this lab really helped me understand how to implement the logic of an issue through code. I disliked the fact that the lab did not give a quick summary of what each error should do because I got very confused on the two errors which were stack underflow and the error that stated that too few items remained were difficult to implement because I did not when each of these errors should appear so my test cases would fail, so for this one I needed help on how to identify how I could implement both these errors so the user understood exactly what was happening so they could actually input a valid token. The hardest part of this lab was making code that checked whether or not the user input was valid or not. Also another really difficult part of this lab was the fact that my results on my terminal and my nucleo were different and then after discussing with my collaborators I realized I had to add /r to fix it. This lab was worthwhile because I had so much fun learning how the whole RPN calculation worked and creating the stack function were probably the most fun and easiest thing I have done in this entire lab. The points distribution for the grading does seem appropriate. I feel like the lab did cover majority of the material as it also listed all the readings needed and at the end it also gave more information, but it could have given some description about each of the errors because two of the errors were very difficult to implement because seemed so similar that I could not decide where to put what. I have already mentioned a few sentences above which errors they are but I feel just giving one or two sentences for each error would be really helpful so that way the student could efficiently finish this assignment. The examples and discussion in help did help me understand this lab and the reading as well. Overall, the lab manual was good except for the one suggestion I have made and I also felt like my end result of the lab was meeting the requirements. 

▪ Specific question about debugging: 
● How did you use the debugger (either through the IDE or through gdb, etc) to help you solve problems in your code? 
I used the debugger to track down logic errors in my code like for example I set different breakpoints so that way I could pause the code and then see the variable at this part of the code. This really helped me find my issues faster and made my debugging process a lot more efficient. 

● How much RAM and Flash does your code use in the Nucleo when debugging? In release mode?
When debugging RAM uses 2.3% (3004 bytes out of 131072 bytes) and Flash uses 7.1% (37100 bytes from 524288 bytes). In release mode RAM uses 2.3% (3004 bytes out of 131072 bytes) and Flash uses 6.8% (35668 bytes from 524288 bytes). 
